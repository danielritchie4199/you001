<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PC 오디오 녹음 (마이크/시스템 오디오)</title>
    <style>
      :root {
        --bg: #ffffff;
        --panel: #ffffff;
        --text: #111827;
        --muted: #6b7280;
        --accent: #22c55e;
        --danger: #ef4444;
        --warn: #f59e0b;
        --border: #e5e7eb;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Noto Sans KR, Arial, Apple Color Emoji, Segoe UI Emoji;
        background: linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);
        color: var(--text);
      }
      .container {
        max-width: 980px;
        margin: 32px auto;
        padding: 16px;
      }
      h1 { margin: 0 0 12px; font-size: 22px; }
      .subtitle { color: var(--muted); margin-bottom: 20px; }
      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 16px;
      }
      @media (min-width: 1000px) {
        .grid { grid-template-columns: 1.2fr 0.8fr; }
      }
      .card {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 16px;
        backdrop-filter: none;
      }
      fieldset { border: none; margin: 0; padding: 0; }
      legend { font-weight: 600; margin-bottom: 8px; }
      label { display: block; margin: 8px 0 6px; font-size: 14px; color: var(--muted); }
      select, input[type="text"], input[type="number"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #ffffff;
        color: var(--text);
      }
      .row { display: flex; gap: 10px; }
      .row > * { flex: 1; }
      .inline { display: inline-flex; align-items: center; gap: 8px; }
      .muted { color: var(--muted); font-size: 13px; }
      .help { background: #f9fafb; border: 1px dashed var(--border); border-radius: 10px; padding: 10px 12px; color: var(--muted); }
      .warn { color: var(--warn); }
      .controls { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
      button {
        appearance: none;
        border: 1px solid #d1d5db;
        background: #f8fafc;
        color: #111827;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
      }
      button.primary { background: linear-gradient(180deg, #26d07c 0%, #16a34a 100%); border: none; color: #08210f; font-weight: 700; }
      button.danger { background: linear-gradient(180deg, #ef4444 0%, #b91c1c 100%); border: none; color: #fff; font-weight: 700; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      .meter-wrap { margin-top: 12px; }
      canvas { width: 100%; height: 72px; border-radius: 8px; background: #f3f4f6; border: 1px solid var(--border); display: block; }
      .status-line { display: flex; gap: 16px; align-items: center; margin-top: 10px; color: var(--muted); font-size: 14px; }
      .badge { border: 1px solid var(--border); padding: 4px 8px; border-radius: 999px; font-size: 12px; }
      audio { width: 100%; margin-top: 10px; }
      .out { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 8px; }
      .filename { min-width: 260px; }
      .hidden { display: none !important; }
      .note { font-size: 12px; color: var(--muted); }
      .kicker { font-size: 12px; color: var(--muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.06em; }
    </style>
    <script src="https://unpkg.com/lamejs@1.2.0/lame.min.js" defer onload="window.__mp3Ready__=true" onerror="window.__mp3Ready__=false"></script>
  </head>
  <body>
    <div class="container">
      <h1>PC 오디오 녹음</h1>
      <div class="subtitle">마이크 또는 시스템/탭 오디오를 선택해 mp3/webm/wav로 녹음하고 저장함</div>

      <div class="grid">
        <div class="card">
          <fieldset>
            <legend>1) 소스 선택</legend>
            <div class="row">
              <label class="inline"><input type="radio" name="source" value="mic" checked /> 마이크</label>
              <label class="inline"><input type="radio" name="source" value="system" /> 시스템·탭 오디오(화면 공유)</label>
              <label class="inline"><input type="radio" name="source" value="loopback" /> 시스템(스테레오 믹스)</label>
            </div>
            <label>마이크 장치</label>
            <div class="row">
              <select id="deviceSelect"></select>
              <button id="refreshDevices" title="장치 새로고침">새로고침</button>
            </div>
            <div id="systemHelp" class="help" style="margin-top:10px">
              시스템·탭 오디오 녹음은 Chrome에서 화면(또는 탭) 공유 시 “시스템 오디오 공유” 체크가 필요함. 공유 선택 후 소리가 실제 재생되어야 레벨 미터가 반응함.
            </div>
            <div id="loopbackHelp" class="help" style="margin-top:10px; display:none">
              스테레오 믹스(Loopback) 장치를 통해 윈도우의 시스템 출력을 직접 녹음함. Windows에서 ‘녹음 장치’에서 ‘Stereo Mix/What U Hear/Loopback’ 장치를 활성화해야 목록에 나타남. 보안 정책상 표준 웹 API로는 장치가 없으면 자동 캡처가 불가능함.
            </div>
          </fieldset>

          <fieldset style="margin-top:16px">
            <legend>2) 포맷·품질</legend>
            <div class="row">
              <label class="inline"><input type="radio" name="format" value="mp3" checked /> MP3</label>
              <label class="inline"><input type="radio" name="format" value="webm" /> WebM(Opus)</label>
              <label class="inline"><input type="radio" name="format" value="wav" /> WAV(PCM)</label>
            </div>

            <div id="opts-mp3" class="opts card" style="margin-top:12px">
              <div class="kicker">MP3 옵션</div>
              <div class="row">
                <div>
                  <label>비트레이트(kbps)</label>
                  <select id="mp3Kbps">
                    <option>96</option>
                    <option>128</option>
                    <option selected>192</option>
                    <option>256</option>
                    <option>320</option>
                  </select>
                </div>
                <div>
                  <label>채널</label>
                  <select id="mp3Channels">
                    <option value="1">모노(1ch)</option>
                    <option value="2" selected>스테레오(2ch)</option>
                  </select>
                </div>
              </div>
              <div class="note">mp3 인코딩은 브라우저 내 JS 인코더를 사용함(lamejs). CPU 사용량이 증가할 수 있음.</div>
            </div>

            <div id="opts-webm" class="opts card hidden" style="margin-top:12px">
              <div class="kicker">WebM/Opus 옵션</div>
              <div class="row">
                <div>
                  <label>비트레이트(bps)</label>
                  <select id="webmBps">
                    <option value="64000">64000</option>
                    <option value="96000">96000</option>
                    <option value="128000" selected>128000</option>
                    <option value="192000">192000</option>
                    <option value="256000">256000</option>
                  </select>
                </div>
              </div>
              <div class="note">브라우저 내장 인코더 사용. 용량/품질/호환성 균형이 좋음.</div>
            </div>

            <div id="opts-wav" class="opts card hidden" style="margin-top:12px">
              <div class="kicker">WAV/PCM 옵션</div>
              <div class="row">
                <div>
                  <label>채널</label>
                  <select id="wavChannels">
                    <option value="1">모노(1ch)</option>
                    <option value="2" selected>스테레오(2ch)</option>
                  </select>
                </div>
              </div>
              <div class="note">무손실이지만 용량 큼. 샘플레이트는 입력 소스의 `AudioContext` 샘플레이트를 사용함.</div>
            </div>
          </fieldset>

          <fieldset style="margin-top:16px">
            <legend>3) 녹음</legend>
            <div class="controls">
              <button id="startBtn" class="primary">시작</button>
              <button id="pauseBtn" disabled>일시정지</button>
              <button id="resumeBtn" disabled>재개</button>
              <button id="stopBtn" class="danger" disabled>정지·저장</button>
            </div>
            <div class="status-line">
              <div><span class="badge" id="statusBadge">대기</span></div>
              <div>경과: <span id="elapsed">00:00</span></div>
              <div>샘플레이트: <span id="sr">-</span> Hz</div>
            </div>
            <div class="meter-wrap">
              <canvas id="meter" width="900" height="90"></canvas>
            </div>
          </fieldset>
        </div>

        <div class="card">
          <fieldset>
            <legend>출력</legend>
            <label>파일명</label>
            <input id="filename" class="filename" type="text" placeholder="자동 생성: rec_{source}_{fmt}_{YYYYMMDD_HHMMSS}" />
            <audio id="player" controls class="hidden"></audio>
            <div class="out">
              <button id="downloadBtn" disabled>다운로드</button>
              <button id="saveAsBtn" disabled title="다른 위치로 저장 (Chrome 보안 컨텍스트에서 지원)">다른 위치로 저장</button>
              <button id="playBtn" disabled>재생</button>
              <span id="outInfo" class="muted"></span>
            </div>
          </fieldset>
          <div style="margin-top:16px" class="help">
            오류가 발생하면 브라우저 권한 설정을 확인하고, 시스템 오디오는 화면 공유 대화상자에서 “시스템 오디오 공유”를 반드시 체크해야 함.
          </div>
        </div>
      </div>
    </div>

    <script>
      // 상태 변수
      let mediaStream = null;
      let mediaRecorder = null; // webm 전용
      let recordedChunks = [];
      let audioContext = null;
      let sourceNode = null;
      let analyserNode = null;
      let processorNode = null; // PCM 수집용 (mp3/wav)
      let monitorGainNode = null; // 무음 모니터링용
      let drawId = null;
      let recordingStartAt = 0;
      let elapsedTimer = null;
      let pausedPcm = false; // PCM 경로 일시정지 플래그
      let pcmBuffers = []; // Float32Array[] 누적 (wav/mp3)
      let pcmChannels = 2;  // 현재 수집 채널수
      let currentFormat = 'mp3';
      let mp3Supported = false;

      const $ = (sel) => document.querySelector(sel);
      const $$ = (sel) => Array.from(document.querySelectorAll(sel));

      function setBadge(text, color) {
        const el = $('#statusBadge');
        el.textContent = text;
        el.style.background = 'transparent';
        el.style.borderColor = 'var(--border)';
        if (color === 'green') el.style.background = '#14532d';
        if (color === 'red') el.style.background = '#3f1d1d';
        if (color === 'amber') el.style.background = '#3a2a12';
      }

      function formatTime(ms) {
        const s = Math.floor(ms / 1000);
        const m = Math.floor(s / 60);
        const r = s % 60;
        return `${String(m).padStart(2, '0')}:${String(r).padStart(2, '0')}`;
      }

      function fileNameBase() {
        const src = document.querySelector('input[name="source"]:checked').value;
        const fmt = document.querySelector('input[name="format"]:checked').value;
        const now = new Date();
        const stamp = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
        return `rec_${src}_${fmt}_${stamp}`;
      }

      function setUiState(state) {
        // state: idle | recording | paused | stopped
        $('#startBtn').disabled = state !== 'idle' && state !== 'stopped';
        $('#pauseBtn').disabled = state !== 'recording';
        $('#resumeBtn').disabled = state !== 'paused';
        $('#stopBtn').disabled = state !== 'recording' && state !== 'paused';
      }

      function showFormatOptions(fmt) {
        $$('.opts').forEach(el => el.classList.add('hidden'));
        if (fmt === 'mp3') $('#opts-mp3').classList.remove('hidden');
        if (fmt === 'webm') $('#opts-webm').classList.remove('hidden');
        if (fmt === 'wav') $('#opts-wav').classList.remove('hidden');
      }

      async function listDevices() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const inputs = devices.filter(d => d.kind === 'audioinput');
          const sel = $('#deviceSelect');
          sel.innerHTML = '';
          for (const d of inputs) {
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.textContent = d.label || `마이크(${d.deviceId.substring(0,6)}…)`;
            sel.appendChild(opt);
          }
          // loopback 후보가 보이면 안내 표시 강화
          const hasLoop = inputs.some(d => /stereo mix|what u hear|loopback/i.test(d.label));
          $('#loopbackHelp').style.display = hasLoop ? 'block' : 'none';
        } catch (e) {
          console.error(e);
        }
      }

      function stopTracks(stream) {
        if (!stream) return;
        for (const t of stream.getTracks()) {
          try { t.stop(); } catch {}
        }
      }

      function cleanup(resetUi = true) {
        stopTracks(mediaStream);
        mediaStream = null;
        if (mediaRecorder) {
          try { mediaRecorder.ondataavailable = null; mediaRecorder.onstop = null; mediaRecorder.stop(); } catch {}
        }
        mediaRecorder = null;
        recordedChunks = [];
        if (processorNode) { try { processorNode.disconnect(); } catch {} processorNode = null; }
        if (monitorGainNode) { try { monitorGainNode.disconnect(); } catch {} monitorGainNode = null; }
        if (analyserNode) { try { analyserNode.disconnect(); } catch {} analyserNode = null; }
        if (sourceNode) { try { sourceNode.disconnect(); } catch {} sourceNode = null; }
        if (audioContext) { try { audioContext.close(); } catch {} audioContext = null; }
        if (drawId) { cancelAnimationFrame(drawId); drawId = null; }
        pausedPcm = false;
        pcmBuffers = [];
        if (resetUi) {
          $('#player').classList.add('hidden');
          $('#outInfo').textContent = '';
          $('#downloadBtn').disabled = true;
          const playBtn = document.getElementById('playBtn');
          if (playBtn) playBtn.disabled = true;
          $('#sr').textContent = '-';
          setUiState('idle');
          setBadge('대기', '');
          updateElapsed(0);
        }
      }

      function updateElapsed(ms) {
        $('#elapsed').textContent = formatTime(ms);
      }

      function startElapsedTimer() {
        recordingStartAt = performance.now();
        if (elapsedTimer) clearInterval(elapsedTimer);
        elapsedTimer = setInterval(() => {
          const now = performance.now();
          updateElapsed(now - recordingStartAt);
        }, 200);
      }

      function stopElapsedTimer() {
        if (elapsedTimer) clearInterval(elapsedTimer);
        elapsedTimer = null;
      }

      function drawMeter() {
        const canvas = $('#meter');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;
        const data = new Uint8Array(analyserNode.fftSize);
        function loop() {
          drawId = requestAnimationFrame(loop);
          ctx.clearRect(0,0,W,H);
          ctx.fillStyle = '#f3f4f6';
          ctx.fillRect(0,0,W,H);
          analyserNode.getByteTimeDomainData(data);
          let peak = 0;
          for (let i=0;i<data.length;i++) {
            const v = (data[i]-128)/128;
            const a = Math.abs(v);
            if (a>peak) peak=a;
          }
          const level = Math.min(1, peak*1.8);
          const barW = W * level;
          ctx.fillStyle = level > 0.8 ? '#ef4444' : level > 0.5 ? '#f59e0b' : '#22c55e';
          ctx.fillRect(0, H/2 - 14, barW, 28);
          ctx.strokeStyle = '#e5e7eb';
          ctx.strokeRect(0.5, H/2 - 14.5, W-1, 29);
        }
        loop();
      }

      function mixToMono(inputL, inputR) {
        const out = new Float32Array(inputL.length);
        for (let i=0;i<inputL.length;i++) out[i] = (inputL[i] + inputR[i]) * 0.5;
        return out;
      }

      function floatTo16BitPCM(float32) {
        const out = new Int16Array(float32.length);
        for (let i=0;i<float32.length;i++) {
          let s = Math.max(-1, Math.min(1, float32[i]));
          out[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
        }
        return out;
      }

      function encodeWav(channelsData, sampleRate) {
        // channelsData: [Float32Array(L), Float32Array(R?)] same length per buffer chunk concatenated beforehand
        // 먼저 interleave 후 WAV 헤더 작성
        const numChannels = channelsData.length;
        const length = channelsData[0].length;
        let interleaved;
        if (numChannels === 2) {
          const L = channelsData[0];
          const R = channelsData[1];
          interleaved = new Float32Array(length * 2);
          for (let i=0, j=0; i<length; i++, j+=2) {
            interleaved[j] = L[i];
            interleaved[j+1] = R[i];
          }
        } else {
          interleaved = channelsData[0];
        }
        const pcm16 = floatTo16BitPCM(interleaved);
        const blockAlign = numChannels * 2; // 16bit
        const byteRate = sampleRate * blockAlign;
        const dataSize = pcm16.byteLength;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);
        function writeStr(off, s) { for (let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i)); }
        let off = 0;
        writeStr(off, 'RIFF'); off += 4;
        view.setUint32(off, 36 + dataSize, true); off += 4;
        writeStr(off, 'WAVE'); off += 4;
        writeStr(off, 'fmt '); off += 4;
        view.setUint32(off, 16, true); off += 4; // PCM fmt chunk size
        view.setUint16(off, 1, true); off += 2; // PCM format
        view.setUint16(off, numChannels, true); off += 2;
        view.setUint32(off, sampleRate, true); off += 4;
        view.setUint32(off, byteRate, true); off += 4;
        view.setUint16(off, blockAlign, true); off += 2;
        view.setUint16(off, 16, true); off += 2; // bits per sample
        writeStr(off, 'data'); off += 4;
        view.setUint32(off, dataSize, true); off += 4;
        new Int16Array(buffer, 44).set(pcm16);
        return new Blob([buffer], { type: 'audio/wav' });
      }

      function concatFloat32(chunks) {
        let total = 0; for (const c of chunks) total += c.length;
        const out = new Float32Array(total);
        let off = 0; for (const c of chunks) { out.set(c, off); off += c.length; }
        return out;
      }

      async function startRecording() {
        cleanup();
        const source = document.querySelector('input[name="source"]:checked').value;
        const fmt = document.querySelector('input[name="format"]:checked').value;
        currentFormat = fmt;
        const deviceId = $('#deviceSelect').value || undefined;
        try {
          if (source === 'mic') {
            mediaStream = await navigator.mediaDevices.getUserMedia({
              audio: {
                deviceId: deviceId ? { exact: deviceId } : undefined,
                echoCancellation: false, noiseSuppression: false, autoGainControl: false
              }
            });
          } else if (source === 'system') {
            // 시스템 오디오는 video 동반 필요할 수 있음
            mediaStream = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: true });
            // 비디오 트랙은 비활성화(정지하면 일부 브라우저에서 전체가 종료됨). 시각 노이즈 방지
            const v = mediaStream.getVideoTracks()[0];
            if (v) v.enabled = false;
          } else if (source === 'loopback') {
            // 사용자가 Stereo Mix/Loopback 장치를 활성화한 경우, 해당 장치를 선택하지 않고도 기본 입력으로 캡처 시도
            // 표준 웹 API로는 시스템 출력에 직접 접근 불가하므로, OS에서 노출하는 루프백 장치가 있어야 함.
            const devices = await navigator.mediaDevices.enumerateDevices();
            const selEl = document.getElementById('deviceSelect');
            const selectedId = selEl && selEl.value ? selEl.value : null;
            let loop = devices.find(d => d.kind === 'audioinput' && /stereo mix|what u hear|loopback/i.test(d.label));
            // 사용자가 장치를 수동 선택했다면 우선 사용 (루프백이 맞는지 여부는 사용자가 인지)
            if (!loop && selectedId) loop = devices.find(d => d.kind === 'audioinput' && d.deviceId === selectedId) || null;
            const loopConstraints = loop ? { deviceId: { exact: loop.deviceId } } : {};
            mediaStream = await navigator.mediaDevices.getUserMedia({
              audio: {
                ...loopConstraints,
                echoCancellation: false, noiseSuppression: false, autoGainControl: false
              }
            });
            if (!loop) {
              alert('루프백(스테레오 믹스) 장치를 찾지 못했음. Windows의 녹음 장치에서 "Stereo Mix/What U Hear/Loopback"을 활성화하거나, 화면 공유 방식에서 "시스템 오디오 공유"를 사용하세요.');
            }
          }
        } catch (err) {
          alert('오디오 소스 획득 실패: ' + (err && err.message ? err.message : err));
          cleanup();
          return;
        }

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        sourceNode = audioContext.createMediaStreamSource(mediaStream);
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;
        sourceNode.connect(analyserNode);
        drawMeter();
        $('#sr').textContent = String(audioContext.sampleRate);

        recordingStartAt = performance.now();
        startElapsedTimer();
        setUiState('recording');
        setBadge('녹음중', 'green');

        if (fmt === 'webm' && typeof MediaRecorder !== 'undefined') {
          const bps = parseInt($('#webmBps').value, 10);
          try {
            mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm;codecs=opus', bitsPerSecond: bps });
          } catch (e) {
            alert('WebM/Opus 인코더를 초기화할 수 없음. 다른 포맷을 선택하세요. ' + e);
            stopRecording();
            return;
          }
          recordedChunks = [];
          mediaRecorder.ondataavailable = (ev) => {
            if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
          };
          mediaRecorder.onstop = finalizeWebm;
          mediaRecorder.start(250);
          return;
        }

        // WAV 또는 MP3 경로: ScriptProcessor로 PCM 수집
        pcmBuffers = [[], []]; // L, R 또는 [mono, ignored]
        const wantChannels = (fmt === 'wav') ? parseInt($('#wavChannels').value, 10) : parseInt($('#mp3Channels').value, 10);
        pcmChannels = wantChannels;
        const processorSize = 4096;
        processorNode = audioContext.createScriptProcessor(processorSize, 2, 2);
        sourceNode.connect(processorNode);
        // 무음 모니터링 경로(루프 방지): 그래프에 연결은 하되 출력되지 않도록 0게인 노드 사용
        monitorGainNode = audioContext.createGain();
        monitorGainNode.gain.value = 0;
        processorNode.connect(monitorGainNode);
        monitorGainNode.connect(audioContext.destination);
        pausedPcm = false;
        processorNode.onaudioprocess = (e) => {
          if (pausedPcm) return;
          const inL = e.inputBuffer.getChannelData(0);
          const inR = e.inputBuffer.numberOfChannels > 1 ? e.inputBuffer.getChannelData(1) : e.inputBuffer.getChannelData(0);
          if (wantChannels === 1) {
            pcmBuffers[0].push(mixToMono(inL, inR));
          } else {
            pcmBuffers[0].push(new Float32Array(inL));
            pcmBuffers[1].push(new Float32Array(inR));
          }
        };
      }

      function finalizeWebm() {
        stopElapsedTimer();
        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
        presentOutput(blob, 'webm');
        cleanup(false);
        setUiState('stopped');
        setBadge('완료', '');
      }

      async function stopRecording() {
        try {
          if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            return; // finalizeWebm에서 마무리함
          }
        } catch {}

        // PCM 경로 마무리
        stopElapsedTimer();
        try { if (processorNode) processorNode.disconnect(); } catch {}
        try { if (sourceNode) sourceNode.disconnect(); } catch {}
        try { if (analyserNode) analyserNode.disconnect(); } catch {}

        // 버퍼 합치기
        const L = concatFloat32(pcmBuffers[0]);
        const R = (pcmChannels === 2) ? concatFloat32(pcmBuffers[1]) : null;
        const sr = audioContext ? audioContext.sampleRate : 48000;

        if (currentFormat === 'wav') {
          const blob = encodeWav(pcmChannels === 2 ? [L, R] : [L], sr);
          presentOutput(blob, 'wav');
          cleanup(false);
          setUiState('stopped');
          setBadge('완료', '');
          return;
        }

        if (currentFormat === 'mp3') {
          if (!window.__mp3Ready__ || !window.lamejs) {
            alert('mp3 인코더(lamejs)를 사용할 수 없음. 인터넷 연결 또는 CDN 접근을 확인하거나 다른 포맷을 선택하세요.');
            cleanup();
            setUiState('idle');
            setBadge('대기', '');
            return;
          }
          const kbps = parseInt($('#mp3Kbps').value, 10);
          const channels = pcmChannels;
          const mp3encoder = new lamejs.Mp3Encoder(channels, sr, kbps);
          const mp3Data = [];
          const left16 = floatTo16BitPCM(L);
          let right16 = null;
          if (channels === 2 && R) right16 = floatTo16BitPCM(R);
          const chunkSize = 1152; // mp3 frame size
          for (let i=0; i<left16.length; i+=chunkSize) {
            const l = left16.subarray(i, i+chunkSize);
            let mp3buf;
            if (channels === 2 && right16) {
              const r = right16.subarray(i, i+chunkSize);
              mp3buf = mp3encoder.encodeBuffer(l, r);
            } else {
              mp3buf = mp3encoder.encodeBuffer(l);
            }
            if (mp3buf.length > 0) mp3Data.push(new Int8Array(mp3buf));
          }
          const end = mp3encoder.flush();
          if (end.length > 0) mp3Data.push(new Int8Array(end));
          const blob = new Blob(mp3Data, { type: 'audio/mpeg' });
          presentOutput(blob, 'mp3');
          cleanup(false);
          setUiState('stopped');
          setBadge('완료', '');
          return;
        }
      }

      function presentOutput(blob, ext) {
        const player = $('#player');
        const url = URL.createObjectURL(blob);
        player.src = url;
        player.classList.remove('hidden');
        $('#downloadBtn').disabled = false;
        const saveAsBtn = document.getElementById('saveAsBtn');
        const playBtn = document.getElementById('playBtn');
        if (playBtn) {
          playBtn.disabled = false;
          playBtn.onclick = () => { try { player.currentTime = 0; player.play(); } catch (e) {} };
        }
        const base = $('#filename').value.trim() || fileNameBase();
        const name = `${base}.${ext}`;
        $('#downloadBtn').onclick = () => {
          const a = document.createElement('a');
          a.href = url; a.download = name; a.click();
        };
        if (saveAsBtn) {
          saveAsBtn.disabled = false;
          saveAsBtn.onclick = async () => {
            try {
              if (!('showSaveFilePicker' in window)) {
                alert('이 브라우저에서는 파일 저장 위치 선택 API가 지원되지 않음. Chrome 최신/보안 컨텍스트(https 또는 localhost)에서 이용하세요.');
                return;
              }
              const handle = await window.showSaveFilePicker({
                suggestedName: name,
                types: [
                  { description: 'Audio', accept: { 'audio/*': [`.${ext}`] } }
                ]
              });
              const writable = await handle.createWritable();
              await writable.write(blob);
              await writable.close();
            } catch (e) {
              if (e && e.name === 'AbortError') return; // 사용자 취소
              console.error(e);
              alert('저장에 실패했음: ' + (e && e.message ? e.message : e));
            }
          };
        }
        $('#outInfo').textContent = `${name} · ${(blob.size/1024/1024).toFixed(2)} MB`;
      }

      function pauseRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.pause();
          stopElapsedTimer();
          setUiState('paused');
          setBadge('일시정지', 'amber');
          return;
        }
        // PCM 경로
        pausedPcm = true;
        stopElapsedTimer();
        setUiState('paused');
        setBadge('일시정지', 'amber');
      }

      function resumeRecording() {
        if (mediaRecorder && mediaRecorder.state === 'paused') {
          mediaRecorder.resume();
          startElapsedTimer();
          setUiState('recording');
          setBadge('녹음중', 'green');
          return;
        }
        pausedPcm = false;
        startElapsedTimer();
        setUiState('recording');
        setBadge('녹음중', 'green');
      }

      function onFormatChange() {
        const fmt = document.querySelector('input[name="format"]:checked').value;
        showFormatOptions(fmt);
      }

      function syncFeatureAvailability() {
        // mp3 지원 여부
        mp3Supported = !!(window.__mp3Ready__ && window.lamejs);
        const mp3Radio = document.querySelector('input[name="format"][value="mp3"]');
        const mp3Opts = $('#opts-mp3');
        if (!mp3Supported) {
          mp3Radio.disabled = true;
          if (mp3Radio.checked) {
            document.querySelector('input[name="format"][value="webm"]').checked = true;
            showFormatOptions('webm');
          }
          mp3Opts.classList.add('hidden');
          mp3Opts.insertAdjacentHTML('beforeend', '<div class="note warn">mp3 인코더를 불러오지 못함. 인터넷 연결 또는 CDN 접근을 확인하세요.</div>');
        }
        // webm 지원 여부
        const webmRadio = document.querySelector('input[name="format"][value="webm"]');
        try {
          const ok = typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported('audio/webm;codecs=opus');
          if (!ok) {
            webmRadio.disabled = true;
            if (webmRadio.checked) {
              const alt = mp3Supported ? 'mp3' : 'wav';
              document.querySelector(`input[name="format"][value="${alt}"]`).checked = true;
              showFormatOptions(alt);
            }
            $('#opts-webm').classList.add('hidden');
          }
        } catch {}
      }

      window.addEventListener('load', async () => {
        // 장치 권한 프롬프트를 위해 한 번 빈 getUserMedia 시도(일부 환경에서 필요)
        try { await navigator.mediaDevices.getUserMedia({ audio: true }); } catch {}
        await listDevices();
        $('#refreshDevices').addEventListener('click', listDevices);
        $$('input[name="format"]').forEach(r => r.addEventListener('change', onFormatChange));
        $$('input[name="source"]').forEach(r => r.addEventListener('change', () => {
          const isSys = document.querySelector('input[name="source"]:checked').value === 'system';
          $('#systemHelp').style.display = isSys ? 'block' : 'none';
          const isLoop = document.querySelector('input[name="source"]:checked').value === 'loopback';
          $('#loopbackHelp').style.display = isLoop ? 'block' : 'none';
        }));
        onFormatChange();
        syncFeatureAvailability();

        $('#startBtn').addEventListener('click', startRecording);
        $('#pauseBtn').addEventListener('click', pauseRecording);
        $('#resumeBtn').addEventListener('click', resumeRecording);
        $('#stopBtn').addEventListener('click', stopRecording);
        setUiState('idle');
        setBadge('대기', '');
      });
    </script>
  </body>
  </html>

